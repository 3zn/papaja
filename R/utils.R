#' Validate function input
#'
#' This functions can be used to validate the input to functions. \emph{This function is not exported.}
#'
#' @param x
#' @param name Character. Name of variable to validate; if \code{NULL} variable name of object supplied to \code{x} is used.
#' @param check_class Character. Name of class to expect.
#' @param check_integer Logical. If \code{TRUE} an object of type \code{integer} or an whole number \code{numeric} is expected.
#' @param check_NA Logical. If \code{TRUE} an non-\code{NA} object is expected.
#' @param check_infinite Logical. If \code{TRUE} a finite object is expected.
#' @param check_length Integer. Length of the object to expect.
#' @param check_dim Numeric. Vector of object dimensions to expect.
#' @param check_range Numeric. Vector of length 2 defining the expected range of the object.
#'
#' @examples
#' in_paren <- TRUE # Taken from printnum()
#' validate(in_paren, check_class = "logical", check_length = 1)
#' validate(in_paren, check_class = "numeric", check_length = 1)

validate <- function(
  x
  , name = NULL
  , check_class = NULL
  , check_integer = FALSE
  , check_NA = TRUE
  , check_infinite = TRUE
  , check_length = NULL
  , check_dim = NULL
  , check_range = NULL
) {
  if(is.null(name)) name <- deparse(substitute(x))

  if(is.null(x)) stop(paste("The parameter '", name, "' is NULL.", sep = ""))

  if(!is.null(check_dim) && !all(dim(x) == check_dim)) stop(paste("The parameter '", name, "' must have dimensions " , paste(check_dim, collapse=""), ".", sep = ""))
  if(!is.null(check_length) && length(x) != check_length) stop(paste("The parameter '", name, "' must be of length ", check_length, ".", sep = ""))

  if(any(is.na(x))) {
    if(check_NA) stop(paste("The parameter '", name, "' is NA.", sep = ""))
    else return(TRUE)
  }

  if(check_infinite && "numeric" %in% is(x) && is.infinite(x)) stop(paste("The parameter '", name, "' must be finite.", sep = ""))
  if(check_integer && "numeric" %in% is(x) && x %% 1 != 0) stop(paste("The parameter '", name, "' must be an integer.", sep = ""))

  for(x.class in check_class) {
    if(!is(x, x.class)) stop(paste("The parameter '", name, "' must be of class '", x.class, "'.", sep = ""))
  }

  if(!is.null(check_range) && any(x < check_range[1] | x > check_range[2])) stop(paste("The parameter '", name, "' must be between ", check_range[1], " and ", check_range[2], ".", sep = ""))
  TRUE
}


#' Convert name of statistic
#'
#' This functions converts a character generated by R-functions that describes a statistic and converts it into the
#' corresponding character required by APA guidelines (6th edition). \emph{This function is not exported.}
#'
#' @param x Chracter.
#'
#' @examples
#' convert_stat_name("rho")
#' convert_stat_name("mean of the differences")
#' convert_stat_name("t")

convert_stat_name <- function(x) {
  validate(x, check_class = "character")

  new_stat_name <- tolower(x)

  new_stat_name <- gsub("-squared", "^2", new_stat_name)

  if(length(new_stat_name) == 2 && grepl("mean", new_stat_name)) new_stat_name <- "\\Delta M"
  if(all(grepl("prop \\d", new_stat_name))) {
    new_stat_name <- NULL
    return(new_stat_name)
  }

  new_stat_name <- switch(
    new_stat_name
    , new_stat_name
    , cor = "r"
    , rho = "r_{\\mathrm{s}}"
    , tau = "\\uptau"
    , `mean of x` = "M"
    , `(pseudo)median` = "Mdn^*"
    , `mean of the differences` = "M_d"
    , `difference in location` = "Mdn_d"
    , `bartlett's k^2` = "K^2"
  )

  new_stat_name <- gsub("x|chi", "\\\\Chi", new_stat_name)

  new_stat_name
}


#' Create confidence interval string
#'
#' Creates a character string from an object with attribute. \emph{This function is not exported.}
#'
#' @param x Numeric. Either a \code{vector} of length 2 with attribute \code{conf.level} or a two-column \code{matrix}
#'    and confidence region bounds as column names (e.g. "2.5 \%" and "97.5 \%") and coefficient names as row names.
#' @param conf_level Numeric. Vector of length 2 giving the lower and upper bounds of the confidence region in case
#'    they cannot be determined from column names or attributes of \code{x}.
#' @param ... Arguments to pass to \code{\link{printnum}}.
#'
#' @seealso \code{\link{printnum}}
#' @examples
#' make_confint(c(1, 2), conf_level = 0.95)

make_confint <- function(
  x
  , conf_level = NULL
  , ...
) {
  if(is.data.frame(x)) x <- as.matrix(x)
  ci <- printnum(x, ...)

  if(!is.matrix(x)) {
    if(is.null(conf_level)) conf_level <- attr(x, "conf.level")
    validate(conf_level, check_class = "numeric", check_length = 1)
    if(conf_level < 1) conf_level <- conf_level * 100

    apa_ci <- paste0(conf_level, "% CI $[", paste(ci, collapse = "$, $"), "]$")
  } else {
    if(is.null(conf_level)) {
      conf_level <- as.numeric(gsub("[^.|\\d]", "", colnames(ci), perl = TRUE))
      conf_level <- 100 - conf_level[1] * 2
    }

    if(!is.null(rownames(ci))) {
      terms <- rownames(ci)
      terms <- gsub("\\(|\\)", "", terms) # Sanitize term names
      terms <- gsub("\\W", "_", terms) # Sanitize term names
    } else {
      terms <- 1:nrow(ci)
    }

    apa_ci <- list()
    for(i in 1:length(terms)) {
      apa_ci[[terms[i]]] <- paste0(conf_level, "% CI $[", paste(ci[i, ], collapse = "$, $"), "]$")
    }

    if(length(apa_ci) == 1) apa_ci <- unlist(apa_ci)
  }

  apa_ci
}


#' Create variables from ellipsis
#'
#' Variables passed to a function using the ellipsis are assigned to the calling environment according to their
#' list names. \emph{This function is not exported.}
#'
#' @param ... Variable names and values to create in the calling environment.
#'
#' @examples
#' parse_ellipsis(a = 10, b = 10)
#' a
#' b

parse_ellipsis <- function(...) {
  list2env(list(...), envir = parent.env(environment()))
  TRUE
}


#############################
## assumes object of class 'anova' and returns character string
##
make_f_test <- function(x, op = "(", cp = ")") {
  p_pos <- grep("Pr\\(>F\\)", names(x))
  p <- printp(x[p_pos])
  if(!grepl("<|>", p)) eq <- "= " else eq <- ""
  ftest <- paste0("$F", op, x["Df"], ",", x["Res.Df"], cp, " = ", printnum(x["F"]), "$, $p ", eq, p, "$")
  ftest
}
